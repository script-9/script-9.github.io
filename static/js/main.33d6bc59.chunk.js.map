{"version":3,"sources":["utils/uuid.js","utils/isCassetteDirty.js","utils/getIdbValues.js","components/Nav.js","utils/timeAgo.js","components/Shelf.js","components/Home.js","components/Editor.js","components/Output.js","components/Code.js","utils/useInterval.js","utils/network.js","App.js","serviceWorker.js","index.js"],"names":["uuidv4","replace","c","crypto","getRandomValues","Uint8Array","toString","isCassetteDirty","cassette","a","async","idbId","idb","idbCassette","isDirty","contents","code","getIdbValues","then","keys","Promise","all","map","key","Nav","props","gist","path","setCassette","isOnline","setCovers","version","useState","setIsDirty","useEffect","navigate","isNew","canSave","canDelete","className","to","id","disabled","onClick","updatedCassette","updatedAt","Date","now","uuid","idbValues","times","timeAgo","before","diff","Math","round","t","length","Covers","covers","_","sortBy","reverse","cover","i","value","handleLoad","Shelf","Home","Editor","onChange","e","persist","target","Output","Code","useInterval","callback","delay","savedCallback","useRef","current","setInterval","clearInterval","fetch","response","ok","Error","statusText","App","token","process","REACT_APP_T","setGist","setIsOnline","network","catch","isLocalhost","Boolean","window","location","hostname","match","registerValidSW","swUrl","config","navigator","serviceWorker","register","registration","onupdatefound","installingWorker","installing","onstatechange","state","controller","console","log","onUpdate","onSuccess","error","rootElement","document","getElementById","hasChildNodes","hydrate","render","URL","href","origin","addEventListener","headers","contentType","get","status","indexOf","ready","unregister","reload","checkValidServiceWorker"],"mappings":"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","file":"static/js/main.33d6bc59.chunk.js","sourcesContent":["const uuidv4 = () => {\n  return ([1e7] + -1e3 + -4e3 + -8e3 + -1e11).replace(/[018]/g, c =>\n    (\n      c ^\n      (crypto.getRandomValues(new Uint8Array(1))[0] & (15 >> (c / 4)))\n    ).toString(16),\n  )\n}\n\nexport default uuidv4\n","import * as idb from 'idb-keyval'\n\nconst isCassetteDirty = async cassette => {\n  if (!cassette) {\n    return false\n  } else {\n    if (cassette.idbId) {\n      const idbCassette = await idb.get(cassette.idbId)\n      const isDirty = cassette.contents.code !== idbCassette.contents.code\n      return isDirty\n    } else {\n      const isDirty = !!cassette.contents.code\n      return isDirty\n    }\n  }\n}\n\nexport default isCassetteDirty\n","import * as idb from 'idb-keyval'\n\nconst getIdbValues = () =>\n  idb.keys().then(keys => Promise.all(keys.map(key => idb.get(key))))\n\nexport default getIdbValues\n","import React, { useEffect, useState } from 'react'\nimport { navigate } from '@reach/router'\nimport { Link } from '@reach/router'\nimport * as idb from 'idb-keyval'\nimport uuid from './../utils/uuid'\nimport isCassetteDirty from './../utils/isCassetteDirty'\nimport getIdbValues from './../utils/getIdbValues'\n\nconst Nav = props => {\n  const {\n    gist,\n    path,\n    cassette,\n    setCassette,\n    isOnline,\n    setCovers,\n    version,\n  } = props\n  const [isDirty, setIsDirty] = useState(false)\n\n  useEffect(() => {\n    if (cassette) {\n      navigate(`${path}?idbId=${cassette.idbId}`)\n    } else {\n      navigate(`${path}`)\n    }\n  }, [cassette, path])\n\n  useEffect(() => {\n    isCassetteDirty(cassette).then(setIsDirty)\n  }, [cassette])\n\n  const handleNew = () => {\n    setCassette(null)\n  }\n\n  const handleSave = async () => {\n    const updatedCassette = {\n      ...cassette,\n      updatedAt: Date.now(),\n      idbId: cassette.idbId || uuid(),\n    }\n\n    await idb.set(updatedCassette.idbId, updatedCassette)\n    setCassette(updatedCassette)\n    const idbValues = await getIdbValues()\n    setCovers(idbValues)\n  }\n\n  const handleDelete = async () => {\n    await idb.del(cassette.idbId)\n    setCassette(null)\n    const idbValues = await getIdbValues()\n    setCovers(idbValues)\n  }\n\n  const isNew = !cassette || !cassette.contents.code\n  const canSave = isDirty && cassette.contents.code\n  const canDelete = cassette\n\n  return (\n    <nav>\n      <div className=\"pages\">\n        <ul>\n          <li>\n            <Link to={gist ? `/?id=${gist.id}` : '/'}>Home</Link>\n          </li>\n          <li>\n            <Link to={gist ? `/code?id=${gist.id}` : '/code'}>Code</Link>\n          </li>\n        </ul>\n      </div>\n      {!isOnline && <div>OFFLINE</div>}\n      {<div>v{version}</div>}\n      <div className=\"buttons\">\n        <ul>\n          <li>\n            <button disabled={isNew} onClick={handleNew}>\n              New\n            </button>\n          </li>\n          <li>\n            <button disabled={!canSave} onClick={handleSave}>\n              Save\n            </button>\n          </li>\n          <li>\n            <button disabled={!canDelete} onClick={handleDelete}>\n              Delete\n            </button>\n          </li>\n        </ul>\n      </div>\n    </nav>\n  )\n}\n\nexport default Nav\n\n// if (!cassette.uuid) {\n// setCassette((cassette = {}) => ({\n//   ...cassette,\n//   uuid: uuid(),\n// }))\n// }\n// const _handleSave = async () => {\n// if (gist) {\n//   try {\n//     const json = await network.editGist({ gist, cassette, token })\n//     setGist(json)\n//   } catch (error) {}\n// } else {\n//   try {\n//     const json = await network.createGist({ cassette, token })\n//     setGist(json)\n//     navigate(`${path}?id=${json.id}`)\n//   } catch (error) {\n//     // If we got a TypeError,\n//     if (error.name === 'TypeError') {\n//       try {\n//         // and trying to fetch favicon errors out,\n//         await network.fetchFavicon()\n//       } catch (error) {\n//         // then we'll assume this happened because we were offline.\n//         const newCassette = {\n//           ...cassette,\n//           idbId: uuid(),\n//         }\n//         setCassette(newCassette)\n//         // Put the cassette in idb.\n//         try {\n//           await idb.set(newCassette.idbId, newCassette)\n//         } catch (error) {\n//           console.error(error)\n//         }\n//       }\n//     }\n//   }\n// }\n// }\n\n// const loadGist = async gistId => {\n//   try {\n//     const json = await network.fetchGist(gistId)\n//     setGist(json)\n//   } catch (error) {\n//     console.log(error)\n//   }\n// }\n\n// useEffect(() => {\n//   const { search } = window.location\n//   const params = new window.URLSearchParams(search)\n//   const id = params.get('id')\n//   if (!gist && id) {\n//     console.log('fetching id')\n//     loadGist(id)\n//   }\n// }, [])\n// {\n//   /* <li>\n// <Link to={gist ? `/shelf?id=${gist.id}` : '/shelf'}>Shelf</Link>\n// </li> */\n// }\n","const times = [\n  ['second', 1],\n  ['minute', 60],\n  ['hour', 3600],\n  ['day', 86400],\n  ['week', 604800],\n  ['month', 2592000],\n  ['year', 31536000],\n]\n\nconst timeAgo = ({ now, before }) => {\n  let diff = Math.round((now - before) / 1000)\n  for (let t = 0; t < times.length; t++) {\n    if (diff < times[t][1]) {\n      if (t === 0) {\n        return 'Just now'\n      } else {\n        diff = Math.round(diff / times[t - 1][1])\n        return diff + ' ' + times[t - 1][0] + (diff === 1 ? ' ago' : 's ago')\n      }\n    }\n  }\n}\n\nexport default timeAgo\n","import React from 'react'\nimport _ from 'lodash'\nimport timeAgo from './../utils/timeAgo'\nimport * as idb from 'idb-keyval'\nimport { navigate } from '@reach/router'\n\nconst Covers = props => {\n  const { covers, setCassette, cassette } = props\n  const now = Date.now()\n\n  const handleLoad = async idbId => {\n    const value = await idb.get(idbId)\n    setCassette(value)\n    navigate(`/code`)\n  }\n\n  return (\n    <ul className=\"Covers\">\n      {_(covers)\n        .sortBy(['updatedAt'])\n        .reverse()\n        .map((cover, i) => (\n          <li key={i}>\n            <div>\n              <span className=\"time-ago\">\n                {timeAgo({ now, before: cover.updatedAt })}\n              </span>\n              <button\n                disabled={cassette && cover.idbId === cassette.idbId}\n                onClick={() => handleLoad(cover.idbId)}\n              >\n                Load\n              </button>\n              <span>{cover.contents.code}</span>\n            </div>\n          </li>\n        ))\n        .value()}\n    </ul>\n  )\n}\n\nconst Shelf = props => {\n  return (\n    <>\n      <div className=\"Shelf\">\n        <h1>Shelf</h1>\n        <Covers {...props} />\n      </div>\n    </>\n  )\n}\n\nexport default Shelf\n\n// useEffect(() => {\n// Try getting offline cassettes.\n// idb\n//   .keys()\n//   .then(keys => Promise.all(keys.map(key => idb.get(key))))\n//   .then(things => {\n//     console.log({ things })\n//   })\n//     // Take an array of promises and wait on them all\n// return Promise.all(\n//   // Map our array of chapter urls to\n//   // an array of chapter json promises\n//   story.chapterUrls.map(getJSON)\n// );\n// setCovers([\n//   ...keys.map(key => ({\n//     id: key,\n//     isIdbCassette: true,\n//   })),\n// ])\n//   setCassettes([\n//     { id: 'e4caf0c2cb95499341d1731912c240f8' },\n//     { id: '9b0be7b96b75be367d28b51ecb0a7e55' },\n//     { id: 'c212d83cfb18e58135ea17bc56afba87' },\n//   ])\n// })\n// }, [])\n\n// const loadGist = async gistId => {\n//   try {\n//     const json = await network.fetchGist(gistId)\n//     setGist(json)\n//     navigate(`/code?id=${json.id}`)\n//   } catch (error) {\n//     console.log(error)\n//   }\n// }\n// import React, { useState, useEffect } from 'react'\n// import { navigate } from '@reach/router'\n// import * as idb from 'idb-keyval'\n// import network from './../utils/network'\n// import Nav from './Nav'\n\n// const nullCassette = null\n\n// const newCassetteNotSaved = {\n//   contents: {\n//     code: {},\n//     // also art, music, etc\n//   },\n// }\n\n// const newCassetteSavedOffline = {\n//   idbId: 'uuid',\n//   contents: {\n//     code: {},\n//     // also art, music, etc\n//   },\n// }\n\n// // As soon as we're back online, the offline-only cassette is saved\n// // to GitHub. Once all the saving is done,\n// // if we go to SHELF, we get all the GitHub gists.\n// // Initially we'll have duplicates:\n// // the GitHub-saved one along with the one in idb.\n\n// const newCassetteSavedOfflineAndThenSyncd1stStep = {\n//   idbId: 'uuid',\n//   gist: {},\n//   contents: {\n//     code: {},\n//     // also art, music, etc\n//   },\n// }\n\n// const newCassetteSavedOfflineAndThenSyncd2ndStep = {\n//   gist: {},\n//   contents: {\n//     code: {},\n//     // also art, music, etc\n//   },\n// }\n\n// const onlineCassetteSavedOffline = {\n//   idbId: 'uuid',\n//   gist: {},\n//   contents: {\n//     code: {},\n//     // also art, music, etc\n//   },\n// }\n\n// From this it is obvious that, if a cassette has a idbId,\n// {/* <button>Load</button>\n// {c.id}{' '}\n// <button\n//   disabled={gist && cassette.id === gist.id}\n//   onClick={() => loadGist(cassette.id)}\n// >\n//   Load\n// </button>{' '} */}\n","import React from 'react'\nimport Nav from './Nav'\nimport Shelf from './Shelf'\n\nconst Home = props => {\n  return (\n    <>\n      <Nav {...props} />\n      <div className=\"Home\">\n        <h1>Home</h1>\n        <Shelf {...props} />\n      </div>\n    </>\n  )\n}\n\nexport default Home\n","import React from 'react'\n\nconst Editor = props => {\n  const { cassette, setCassette } = props\n\n  const handleTextareaChange = e => {\n    e.persist()\n    setCassette((cassette = {}) => ({\n      ...cassette,\n      contents: {\n        code: e.target.value,\n      },\n    }))\n  }\n\n  return (\n    <div className=\"Editor\">\n      <h1>Editor</h1>\n      <textarea\n        value={(cassette && cassette.contents.code) || ''}\n        onChange={handleTextareaChange}\n      ></textarea>\n    </div>\n  )\n}\n\nexport default Editor\n","import React from 'react'\n\nconst Output = props => {\n  const { cassette } = props\n  return (\n    <div className=\"Output\">\n      <h1>Output</h1>\n      <pre>{(cassette && cassette.contents.code) || null}</pre>\n    </div>\n  )\n}\n\nexport default Output\n","import React from 'react'\nimport Editor from './Editor'\nimport Output from './Output'\nimport Nav from './Nav'\nimport Shelf from './Shelf'\n\nconst Code = props => {\n  return (\n    <>\n      <Nav {...props} />\n      <div className=\"Code\">\n        <h1>Code</h1>\n        <Editor {...props} />\n        <Output {...props} />\n        <Shelf {...props} />\n      </div>\n    </>\n  )\n}\n\nexport default Code\n","import { useEffect, useRef } from 'react'\n\nconst useInterval = (callback, delay) => {\n  const savedCallback = useRef()\n\n  // Remember the latest callback.\n  useEffect(() => {\n    savedCallback.current = callback\n  }, [callback])\n\n  // Set up the interval.\n  useEffect(() => {\n    function tick() {\n      savedCallback.current()\n    }\n    if (delay !== null) {\n      let id = setInterval(tick, delay)\n      return () => clearInterval(id)\n    }\n  }, [delay])\n}\n\nexport default useInterval\n","const fetchFavicon = () =>\n  fetch('/img/favicon.co').then(response => {\n    if (!response.ok) {\n      throw new Error(response.statusText)\n    }\n    return response\n  })\n\nconst fetchGist = async gistId => {\n  const url = `https://api.github.com/gists/${gistId}`\n  const response = await fetch(url)\n  if (response.status === 200) {\n    const json = await response.json()\n    return json\n  } else {\n    throw new Error(response.statusText)\n  }\n}\n\nconst assembleGistPayload = cassette => ({\n  public: true,\n  description: 'SCRIPT-9',\n  files: {\n    'misc.json': {\n      idbId: cassette.idbId || null,\n    },\n    'code.json': {\n      content: cassette.content,\n    },\n  },\n})\n\nconst editGist = async ({ gist, cassette, token }) => {\n  const payload = assembleGistPayload(cassette)\n  const options = {\n    headers: {\n      Authorization: `token ${token}`,\n      'Content-Type': 'application/json',\n    },\n    body: JSON.stringify(payload),\n  }\n\n  const { id } = gist\n  const url = `https://api.github.com/gists/${id}`\n  options.method = 'PATCH'\n\n  const response = await fetch(url, options)\n  if (response.status === 200) {\n    const json = await response.json()\n    return json\n  } else {\n    throw new Error(response.statusText)\n  }\n}\n\nconst createGist = async ({ cassette, token }) => {\n  const payload = assembleGistPayload(cassette)\n  const options = {\n    headers: {\n      Authorization: `token ${token}`,\n      'Content-Type': 'application/json',\n    },\n    body: JSON.stringify(payload),\n  }\n\n  const url = `https://api.github.com/gists`\n  options.method = 'POST'\n\n  const response = await fetch(url, options)\n  if (response.status === 201) {\n    const json = await response.json()\n    return json\n  } else {\n    throw new Error(`${response.status}: ${response.statusText}`)\n  }\n}\n\nexport default { fetchGist, editGist, createGist, fetchFavicon }\n","import React, { useState, useEffect } from 'react'\nimport { Router } from '@reach/router'\nimport Home from './components/Home'\nimport Code from './components/Code'\nimport useInterval from './utils/useInterval'\nimport getIdbValues from './utils/getIdbValues'\nimport network from './utils/network'\nimport './styl/App.css'\nimport { version } from './../package.json'\n\nconst App = () => {\n  const token = process.env.REACT_APP_T\n  const [gist, setGist] = useState(null)\n  const [cassette, setCassette] = useState(null)\n  const [covers, setCovers] = useState([])\n  const [isOnline, setIsOnline] = useState(true)\n\n  useEffect(() => {\n    getIdbValues().then(setCovers)\n  }, [])\n\n  useInterval(() => {\n    network\n      .fetchFavicon()\n      .then(() => {\n        setIsOnline(true)\n      })\n      .catch(() => {\n        setIsOnline(false)\n      })\n  }, 5000 * 100)\n\n  const props = {\n    version,\n    token,\n    isOnline,\n    gist,\n    setGist,\n    cassette,\n    setCassette,\n    covers,\n    setCovers,\n  }\n  return (\n    <div className=\"App\">\n      <Router>\n        <Home path=\"/\" {...props} />\n        <Code path=\"/code\" {...props} />\n        {/* <Shelf path=\"/shelf\" {...props} /> */}\n      </Router>\n    </div>\n  )\n}\n\nexport default App\n// const { token } = loadState() || { token: process.env.REACT_APP_T }\n// setGist: gist => {\n// setCassette(cassette => {\n//   return gist\n//     ? { ...cassette, content: gist.files['code.json'].content }\n//     : {}\n// })\n// setGist(gist)\n// },\n","// This optional code is used to register a service worker.\n// register() is not called by default.\n\n// This lets the app load faster on subsequent visits in production, and gives\n// it offline capabilities. However, it also means that developers (and users)\n// will only see deployed updates on subsequent visits to a page, after all the\n// existing tabs open on the page have been closed, since previously cached\n// resources are updated in the background.\n\n// To learn more about the benefits of this model and instructions on how to\n// opt-in, read https://bit.ly/CRA-PWA\n\nconst isLocalhost = Boolean(\n  window.location.hostname === 'localhost' ||\n    // [::1] is the IPv6 localhost address.\n    window.location.hostname === '[::1]' ||\n    // 127.0.0.0/8 are considered localhost for IPv4.\n    window.location.hostname.match(\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/,\n    ),\n)\n\nexport function register(config) {\n  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\n    // The URL constructor is available in all browsers that support SW.\n    const publicUrl = new URL(process.env.PUBLIC_URL, window.location.href)\n    if (publicUrl.origin !== window.location.origin) {\n      // Our service worker won't work if PUBLIC_URL is on a different origin\n      // from what our page is served on. This might happen if a CDN is used to\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\n      return\n    }\n\n    window.addEventListener('load', () => {\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`\n\n      if (isLocalhost) {\n        // This is running on localhost. Let's check if a service worker still exists or not.\n        checkValidServiceWorker(swUrl, config)\n\n        // Add some additional logging to localhost, pointing developers to the\n        // service worker/PWA documentation.\n        navigator.serviceWorker.ready.then(() => {\n          console.log(\n            'This web app is being served cache-first by a service ' +\n              'worker. To learn more, visit https://bit.ly/CRA-PWA',\n          )\n        })\n      } else {\n        // Is not localhost. Just register service worker\n        registerValidSW(swUrl, config)\n      }\n    })\n  }\n}\n\nfunction registerValidSW(swUrl, config) {\n  navigator.serviceWorker\n    .register(swUrl)\n    .then(registration => {\n      registration.onupdatefound = () => {\n        const installingWorker = registration.installing\n        if (installingWorker == null) {\n          return\n        }\n        installingWorker.onstatechange = () => {\n          if (installingWorker.state === 'installed') {\n            if (navigator.serviceWorker.controller) {\n              // At this point, the updated precached content has been fetched,\n              // but the previous service worker will still serve the older\n              // content until all client tabs are closed.\n              console.log(\n                'New content is available and will be used when all ' +\n                  'tabs for this page are closed. See https://bit.ly/CRA-PWA.',\n              )\n\n              // Execute callback\n              if (config && config.onUpdate) {\n                config.onUpdate(registration)\n              }\n            } else {\n              // At this point, everything has been precached.\n              // It's the perfect time to display a\n              // \"Content is cached for offline use.\" message.\n              console.log('Content is cached for offline use.')\n\n              // Execute callback\n              if (config && config.onSuccess) {\n                config.onSuccess(registration)\n              }\n            }\n          }\n        }\n      }\n    })\n    .catch(error => {\n      console.error('Error during service worker registration:', error)\n    })\n}\n\nfunction checkValidServiceWorker(swUrl, config) {\n  // Check if the service worker can be found. If it can't reload the page.\n  fetch(swUrl, {\n    headers: { 'Service-Worker': 'script' },\n  })\n    .then(response => {\n      // Ensure service worker exists, and that we really are getting a JS file.\n      const contentType = response.headers.get('content-type')\n      if (\n        response.status === 404 ||\n        (contentType != null && contentType.indexOf('javascript') === -1)\n      ) {\n        // No service worker found. Probably a different app. Reload the page.\n        navigator.serviceWorker.ready.then(registration => {\n          registration.unregister().then(() => {\n            window.location.reload()\n          })\n        })\n      } else {\n        // Service worker found. Proceed as normal.\n        registerValidSW(swUrl, config)\n      }\n    })\n    .catch(() => {\n      console.log(\n        'No internet connection found. App is running in offline mode.',\n      )\n    })\n}\n\nexport function unregister() {\n  if ('serviceWorker' in navigator) {\n    navigator.serviceWorker.ready.then(registration => {\n      registration.unregister()\n    })\n  }\n}\n","import React from 'react'\nimport { hydrate, render } from 'react-dom'\nimport App from './App'\nimport * as serviceWorker from './serviceWorker'\n\nconst rootElement = document.getElementById('root')\nif (rootElement.hasChildNodes()) {\n  hydrate(<App />, rootElement)\n} else {\n  render(<App />, rootElement)\n}\n// If you want your app to work offline and load faster, you can change\n// unregister() to register() below. Note this comes with some pitfalls.\n// Learn more about service workers: https://bit.ly/CRA-PWA\nserviceWorker.register()\n"],"sourceRoot":""}